#!/usr/bin/env python2

"""dbcollect: Collect Oracle database and OS info for all oratab instances"""

helptext = """This tool collects OS and database information and AWR/Statspack
reports for all normal database instances listed in 
/etc/oratab (not starting with + or -).
For this, Oracle SQL*Plus is called to generate the AWRs 
and dbinfo and some OS files (including SAR data) as well as
command output from some commands is collected.
The AWR files as well as the system info reports are placed
in a ZIP file, by default /tmp/[hostname]-dbcollect.zip.

SAR requires sysstat to be installed and 
enabled (in /etc/cron.d/sysstat).

Runs as Oracle user (typically, 'oracle') and requires sysdba
privileges. If called as 'root', switches to user 'oracle' or
other user specified by the '-u' option.
"""

__author__    = "Bart Sjerps <bart@outrun.nl>"
__copyright__ = "Copyright 2019, Bart Sjerps"
__license__   = "GPLv3+"
__version__   = "1.0.1"

import os, sys, socket, subprocess, argparse, pwd, grp
from getpass import getuser
from datetime import date
from zipfile import ZipFile, ZIP_DEFLATED

topdir = os.path.dirname(os.path.realpath(__file__))

awr = """\
define TMPDIR = /tmp
define ZIP    = $ORACLE_HOME/bin/zip
define REMOVE = /bin/rm
define SEP    = /
"""

def checkroot(user):
    """Checks if the user is non-root"""
    if getuser() == 'root':
        try:
            uid = pwd.getpwnam(user).pw_uid
        except:
            print 'User %s not available' % user
            exit(10)
        gid = pwd.getpwnam(user).pw_gid
        os.setgid(gid)
        groups = [g.gr_gid for g in grp.getgrall() if 'oracle' in g.gr_mem]
        groups.append(gid)
        os.setgroups(groups)
        os.setuid(uid)

def issarfile(f):
    """Return True if file is a binary sar file (generated by sa1)"""
    with open(f,'rb') as sa:
        bytes = sa.read(2)
        if bytes == '\x96\xd5':
            return True
    return False

class Zipfile:
    """Zipfile class"""
    def __init__(self, path):
        """Open the zip file with path"""
        # Directory name within zip file are defined by fqdn
        self.fqdn = socket.gethostbyaddr(socket.gethostname())[0]
        self.path = path
        self.zip = None
        print 'Creating zip file %s' % self.path
        try:
            self.zip = ZipFile(self.path,'w', 8)
        except IOError as e:
            print e
            exit(10)
    def __del__(self):
        if self.zip:
            self.zip.close()
    def add(self, tag, data):
        """Store a blob in the zip file with filename=tag"""
        self.zip.writestr("%s/%s" % (self.fqdn, tag), data)
    def store(self, path):
        """Store a file in the ZIP file"""
        self.zip.write(path, "%s/%s" % (self.fqdn, os.path.basename(path)))
    def move(self, path):
        """Move a file to the ZIP file"""
        self.zip.write(path, "%s/%s" % (self.fqdn, os.path.basename(path)))
        os.unlink(path)

def sqlplus(sid, orahome, sql):
    """Run SQL*Plus script or command, stdout/stderr goes to normal console"""
    oraenv = {}
    oraenv['ORACLE_HOME'] = orahome
    oraenv['ORACLE_SID'] = sid
    sqlpluscmd = (os.path.join(orahome, 'bin', 'sqlplus -L -S / as sysdba')).split()
    proc = subprocess.Popen(sqlpluscmd, env=oraenv, stdin=subprocess.PIPE)
    stdout, stderr = proc.communicate(sql)

def sarlogs():
    """Collect sar logs from /var/log/sa"""
    if not os.path.isdir('/var/log/sa'):
        print '/var/log/sa not found, skipping sar logs'
        return
    for f in os.listdir('/var/log/sa'):
        path = os.path.join('/var/log/sa', f)
        if f.startswith('sar'):
            # These are the text reports, not needed
            continue
        if f.startswith('sa') and issarfile(path):
            try:
                print 'retrieving SAR file %s' % path
                zip.store(path)
            except:
                print 'writing to ZIP file failed,', f

def genawrs(days):
    """Run the collect-awr.sql and dbinfo scripts for each instance"""
    if days == None:
        days = ''
    if not os.path.isfile('/etc/oratab'):
        print 'oratab not found'
        return
    if args.statspack:
        scriptname = 'collect-statspack.sql'
    else:
        scriptname = 'collect-awr.sql'
    with open('/etc/oratab') as oratab:
        for line in oratab.readlines():
            if line[0].isalpha():
                sid, orahome, enabled = line.rstrip('\n').split(':')
                proc = subprocess.Popen(('pgrep -xf ora_pmon_%s' % sid).split(), stdout = subprocess.PIPE, stderr = subprocess.PIPE)
                proc.communicate()
                if proc.returncode == 0:
                    spool = os.path.join('/tmp','dbinfo-%s.txt' % sid)
                    dbinfo = os.path.join(topdir,'dbinfo.sql')
                    getawr = os.path.join(topdir, scriptname)
                    print 'getting database info for %s' % sid
                    sql = "set term off\n@%s %s"  % (dbinfo, spool)
                    sqlplus(sid, orahome, sql)
                    print 'getting performance reports for %s' % sid
                    sql = awr + '@%s %s' % (getawr, days)
                    sqlplus(sid, orahome, sql)
                else:
                    print 'skipping instance %s (pmon process for instance not running)' % sid
    for f in os.listdir('/tmp'):
        if '_awr_' in f and f.endswith('.zip'):
            path = os.path.join('/tmp', f)
            zip.move(path)
        elif f.startswith('dbinfo'):
            path = os.path.join('/tmp', f)
            zip.move(path)

#============================================================================
# Main section - parsing options etc
# ---------------------------------------------------------------------------

days = None
parser = argparse.ArgumentParser(description='AWR and system info collector', epilog=helptext)
parser.add_argument("-V", "--version",   action="store_true", help="Version and copyright info")
parser.add_argument(      "--statspack", action="store_true", help="Run statspack instead of AWR")
parser.add_argument("-o", "--output",    type=str, help="output file, default <host>-dbcollect.zip")
parser.add_argument("-t", "--tmpdir",    type=str, help="tempdir, default = /tmp", default='/tmp')
parser.add_argument("-u", "--user",      type=str, help="Run as user (default oracle)", default='oracle')
parser.add_argument("-d", "--days",      type=int, help="Number of days to collect (default 8)")
args = parser.parse_args()

checkroot(args.user)

if args.version:
    print "Author:    %s" % __author__
    print "Copyright: %s" % __copyright__
    print "License:   %s" % __license__
    print "Version:   %s" % __version__
else:
    if args.output:
        outfile = os.path.join(args.tmpdir, args.output)
    else:
        outfile = os.path.join(args.tmpdir, "%s-%s" % (socket.gethostbyaddr(socket.gethostname())[0], 'dbcollect.zip'))
    try:
        zip = Zipfile(outfile)
        genawrs(args.days)
        subprocess.call([os.path.join(topdir, 'syscollect')])
        zip.move('/tmp/syscollect.json')
        zip.move('/tmp/syscollect.log')
        sarlogs()
    except KeyboardInterrupt:
        os.unlink(outfile)
