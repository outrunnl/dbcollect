#!/usr/bin/env python2

"""dbcollect: Collect Oracle database and OS info for all oratab instances"""

helptext = """\
This tool collects OS and database information and AWR/Statspack
reports for all normal database instances listed in
/etc/oratab (not starting with + or -).
For this, Oracle SQL*Plus is called to generate the AWRs
and dbinfo and some OS files (including SAR data) as well as
command output from some commands is collected.
The AWR files as well as the system info reports are placed
in a ZIP file, by default /tmp/[hostname]-dbcollect.zip.

SAR requires sysstat to be installed and
enabled (in /etc/cron.d/sysstat).

Runs as Oracle user (typically, 'oracle') and requires sysdba
privileges. If called as 'root', switches to user 'oracle' or
other user specified by the '-u' option.
"""

__author__    = "Bart Sjerps <bart@outrun.nl>"
__copyright__ = "Copyright 2019, Bart Sjerps"
__license__   = "GPLv3+"
__version__   = "1.1.0"

import os, sys, socket, argparse, tempfile, pwd, grp
from subprocess import Popen, PIPE, call
from getpass import getuser
from datetime import date
from shutil import rmtree
from zipfile import ZipFile, ZIP_DEFLATED

topdir = os.path.dirname(os.path.realpath(__file__))

def checkroot(user):
    """Checks if the user is non-root"""
    if getuser() == 'root':
        try:
            uid = pwd.getpwnam(user).pw_uid
        except:
            print 'User %s not available' % user
            exit(10)
        gid = pwd.getpwnam(user).pw_gid
        os.setgid(gid)
        groups = [g.gr_gid for g in grp.getgrall() if 'oracle' in g.gr_mem]
        groups.append(gid)
        os.setgroups(groups)
        os.setuid(uid)

def issarfile(f):
    """Return True if file is a Linux binary sar file (generated by sa1)"""
    with open(f,'rb') as sa:
        bytes = sa.read(2)
        if bytes == '\x96\xd5':
            return True
    return False

def procexists(name):
    """Return True if process with name exists. Not case sensitive"""
    proc = Popen('ps -eo comm'.split(), stdout = PIPE, stderr = PIPE)
    stdout, stderr = proc.communicate()
    if proc.returncode == 0:
        for line in stdout.splitlines():
            words = line.split()
            if name.lower() in words[0].lower():
                return True
        return False
    else:
        print('error', stderr, proc.returncode)

class Zipfile:
    """Zipfile class"""
    def __init__(self, path):
        """Open the zip file with path"""
        # Directory name within zip file are defined by fqdn
        self.fqdn = socket.gethostbyaddr(socket.gethostname())[0]
        self.path = path
        self.zip = None
        print 'Creating zip file %s' % self.path
        self.zip = ZipFile(self.path,'w', 8)
    def __del__(self):
        if self.zip:
            self.zip.close()
    def add(self, tag, data):
        """Store a blob in the zip file with filename=tag"""
        self.zip.writestr("%s/%s" % (self.fqdn, tag), data)
    def store(self, path):
        """Store a file in the ZIP file"""
        self.zip.write(path, "%s/%s" % (self.fqdn, os.path.basename(path)))
    def move(self, path):
        """Move a file to the ZIP file"""
        self.zip.write(path, "%s/%s" % (self.fqdn, os.path.basename(path)))
        os.unlink(path)

def sqlplus(sid, orahome, sql):
    """Run SQL*Plus script or command, stdout/stderr goes to normal console"""
    env = {}
    env['ORACLE_HOME'] = orahome
    env['ORACLE_SID'] = sid
    sqlpluscmd = (os.path.join(orahome, 'bin', 'sqlplus -L -S / as sysdba')).split()
    proc = Popen(sqlpluscmd, env=env, stdin=PIPE)
    _, _ = proc.communicate(sql)

def sarlogs():
    """Collect sar logs from /var/log/sa"""
    if not os.path.isdir('/var/log/sa'):
        print '/var/log/sa not found, skipping sar logs'
        return
    for f in os.listdir('/var/log/sa'):
        path = os.path.join('/var/log/sa', f)
        if f.startswith('sar'):
            # These are the text reports, not needed
            continue
        if f.startswith('sa') and issarfile(path):
            try:
                print 'retrieving SAR file %s' % path
                zip.store(path)
            except:
                print 'writing to ZIP file failed,', f

def collectora(days, force=0):
    """Run the collect-awr.sql and dbinfo scripts for each instance"""
    if not os.path.isfile('/etc/oratab'):
        print 'oratab not found'
        return
    if args.statspack:
        scriptname = 'collect-statspack.sql'
    else:
        scriptname = 'collect-awr.sql'
    with open('/etc/oratab') as oratab:
        for line in oratab.readlines():
            if line[0].isalpha():
                sid, orahome, enabled = line.rstrip('\n').split(':')
                if procexists('ora_pmon_%s' % sid):
                    spool  = os.path.join(tmpdir,'dbinfo-%s.txt' % sid)
                    dbinfo = os.path.join(topdir,'dbinfo.sql')
                    getawr = os.path.join(topdir, scriptname)
                    print 'getting database info for %s' % sid
                    sql = "set term off\n@%s %s"  % (dbinfo, spool)
                    sqlplus(sid, orahome, sql)
                    print 'getting performance reports for %s' % sid
                    sql = "define TMPDIR = %s\n" \
                        "define ZIP    = $ORACLE_HOME/bin/zip\n" \
                        "define REMOVE = /bin/rm\n" \
                        "define SEP    = /\n" % tmpdir
                    sql += '@%s %d %d %d' % (getawr, days, 0, force)
                    sqlplus(sid, orahome, sql)
                else:
                    print 'skipping instance %s (pmon process for instance not running)' % sid
    for f in os.listdir(tmpdir):
        if '_awr_' in f and f.endswith('.zip') or f.startswith('dbinfo'):
            path = os.path.join(tmpdir, f)
            zip.move(path)

#============================================================================
# Main section - parsing options etc
# ---------------------------------------------------------------------------

parser = argparse.ArgumentParser(description='AWR and system info collector', epilog=helptext)
parser.add_argument("-V", "--version",   action="store_true", help="Version and copyright info")
parser.add_argument("-S", "--statspack", action="store_true", help="Run statspack instead of AWR")
parser.add_argument(      "--force",     action="store_true", help="Run AWR reports even if AWR usage (license) is not detected")
parser.add_argument("-o", "--output",    type=str, help="output file, default <host>-dbcollect.zip")
parser.add_argument("-u", "--user",      type=str, help="Run as user (default oracle)", default='oracle')
parser.add_argument("-d", "--days",      type=int, help="Number of days to collect (default 10)", default=10)
args = parser.parse_args()

if args.version:
    print "Author:    %s" % __author__
    print "Copyright: %s" % __copyright__
    print "License:   %s" % __license__
    print "Version:   %s" % __version__
else:
    checkroot(args.user)
    if args.output:
        outfile = args.output
        if not outfile.endswith('.zip'):
            outfile += '.zip'
    else:
        outfile = os.path.join('/tmp', "%s-%s" % (socket.getfqdn(), 'dbcollect.zip'))
    try:
        tmpdir = tempfile.mkdtemp(prefix='dbcollect-')
        try:
            zip = Zipfile(outfile)
        except IOError as e:
            if e.errno == 13:
                print "Creating zipfile failed (permission denied)\nRemove %s first or use another filename (-o <file>)"
            else:
                print "Creating zipfile failed: %s" % e
            exit()
        try:
            force = 1 if args.force else 0
            collectora(args.days, force)
        except Exception as e:
            print "collect Oracle failed(%s), skipping..." % e
        try:
            collectfile = os.path.join(tmpdir,'syscollect.json')
            collectlog = os.path.join(tmpdir,'syscollect.log')
            call([os.path.join(topdir, 'syscollect'),'-d',tmpdir])
            zip.move(collectfile)
            zip.move(collectlog)
        except Exception as e:
            print "syscollect failed(%s), skipping..." % e
        try:
            sarlogs()
        except Exception as e:
            print "Collecting SAR logs failed(%s), skipping..." % e
    except KeyboardInterrupt:
        os.unlink(outfile)
    finally:
        rmtree(tmpdir)
