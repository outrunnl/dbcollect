#!/usr/bin/env python2

"""syscollect - Collect Linux OS information in JSON format"""

"""\
Note this is written for python 2 as python 3 is not by default installed on EL6 or EL7 systems.
Also there are no dependencies other than the standard python 2 libraries.
"""

helptext = """\
This tool collects Linux OS information and presents this as a JSON file.
This allows reporting tools to process the system info into other formats.

Items to be collected are:

* Current time, timezone, uptime
* CPU, platform and vendor
* OS distro, release
* Storage devices
* Filesystems and mounts
* Network interfaces

This tool is designed to run as non-privileged user for safety. It cannot harm
the system as it makes no changes other than writing the JSON and error log file.
"""

__author__    = "Bart Sjerps <bart@outrun.nl>"
__copyright__ = "Copyright 2019, Bart Sjerps"
__license__   = "GPLv3+"
__version__   = 200622

import sys, os, argparse, json, platform
import socket, subprocess
from datetime import date, datetime, timedelta
from time import strftime, gmtime

name = os.path.basename(__file__)

approved_cmds = {
    'df': 'df -P -T -xtmpfs -xdevtmpfs',
    'udevadm': 'udevadm info -q symlink -n',
    'lsblk6': 'lsblk -PbnDo name,maj:min,kname,type,label,size,fstype,sched',
    'lsblk7': 'lsblk -PbnDo name,maj:min,kname,type,label,size,fstype,sched,wwn,hctl,pkname',
    'lscpu': 'lscpu',
    'ip': 'ip -o -4 addr show'
}

def redir_stderr(logfile):
    """Redirect stderr to a logfile"""
    org = sys.stderr
    sys.stderr = open(logfile, 'w')

def logerr(txt):
    """Log a message to stderr, prefixed with a timestamp"""
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M")
    sys.stdout.write(txt)
    sys.stderr.write('osinfo %s: %s' % (timestamp, txt))

def getfile(path):
    """Read contents of a file, return None if it fails. Strip the last \n from the output."""
    try:
        with open(path) as f:
            return f.read().rstrip('\n')
    except:
        return None

def run(cmd, params=None, hide_errors=False):
    """
    Run a command, and return the output of stdout. Any stderr messages will be logged.
    If the command fails (i.e. does not exists or exits with non-zero return code), logs an error
    Even if the command fails, still an empty string is returnen so the program continues
    """
    command = approved_cmds.get(cmd)
    if not command:
        logerr('command not approved: %s\n' % cmd)
        return ''
    else:
        command = command.split()
    if params:
        command.append(params)
    # We limit PATH to a minimal set to avoid accidentally calling any aliases or wrappers a system may have"
    myenv = {}
    myenv['PATH'] = '/usr/sbin:/usr/bin:/bin:/sbin'
    try:
        proc = subprocess.Popen(command, stdout = subprocess.PIPE, stderr = subprocess.PIPE, stdin=subprocess.PIPE, env=myenv)
        stdout, stderr = proc.communicate()
        if not hide_errors and stderr:
            logerr(stderr)
        return stdout.rstrip('\n')
    except OSError as oe:
        # Command failed or does not exist
        logerr('oserror %s: %s\n' % (cmd[0], str(oe)))
        return ''
    except:
        # Something else went wrong, always write to console
        e = sys.exc_info()
        print ('unknown error: %s', str(e))
        return ''

def jsdump(js):
    """Dump a dict to console in json format. For debugging."""
    json.dump(js, sys.stdout, indent=2,sort_keys=True)
    print

def ipaddr():
    """Get the primary IP address of the system"""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(('10.255.255.255', 1))
        ip = s.getsockname()[0]
    except:
        ip = '127.0.0.1'
    finally:
        s.close()
    return ip

def timestamp():
    """Get timestamp, timezone, startup and uptime. Timestamps in UTC"""
    info = dict()
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M")
    tz = strftime("%Z", gmtime())
    with open('/proc/uptime', 'r') as f:
        uptime_seconds = float(f.readline().split()[0])
        startup = datetime.utcnow() - timedelta(seconds=uptime_seconds)
    info = {
        'timestamp': timestamp,
        'timezone': strftime("%Z", gmtime()),
        'startup': startup.strftime("%Y-%m-%d %H:%M"),
        'uptime': int(uptime_seconds)
    }
    return info

def filesystems():
    """Get filesystems and sizes from 'df', excluding tempfs"""
    arr = []
    df = run('df')
    for line in df.split('\n'):
        dev, fstype, blks, used, avail, cap, mp = line.replace('Mounted on', 'Mountpoint').split()
        if dev in ['Filesystem', 'tmpfs','udev']:
            continue
        arr.append({
            'mountpoint': mp,
            'dev':    dev,
            'type':   fstype,
            'blocks': int(blks),
            'used':   int(used),
            })
    return arr

def devlinks(dev):
    """Get the UDEV symlinks (aliases) for a block device"""
    pathlist = []
    paths = run('udevadm', dev).split()
    for path in paths:
        pathlist.append(path)
    return pathlist

def devices():
    """Report the storage (block) devices on the system using blkid and /sys"""
    arr = []
    dist = platform.dist()[1]
    if dist.startswith('6'):
        lsblk = run('lsblk6')
    else:
        lsblk = run('lsblk7')
    for line in lsblk.split('\n'):
        disk = dict()
        for i in line.split('" '):
            key, rawval = i.partition("=")[::2]
            key = key.lower()
            val = rawval.strip('"').strip()
            if len(val):
                if key in ['size','rq-size']:
                    val = int(val)
                disk[key] = val
        if disk['type'] in ['disk','part']:
            links = devlinks(disk['name'])
            disk['symlinks'] = links
        dev = disk['name']
        #del disk['name']
        for var in ['model','rev','queue_depth','vendor']:
            p = os.path.join('/sys/class/block/%s/device/%s' % (dev, var))
            if os.path.isfile(p):
                val = getfile(p).strip()
                if var in ['queue_depth']:
                    val = int(val)
                disk[var] = val
        arr.append(disk)
    return arr

def cpuinfo():
    """Report CPU model, type, cores, sockets etc"""
    info = dict()
    cpuinfo = run('lscpu')
    sockets, cores, threads, cpus, tpc, cps = 0, 0, 0, 0, 0, 0
    for line in cpuinfo.splitlines():
        key, val = line.split(':')
        val = val.strip()
        # Cleanup a bit
        if key in ['Flags','Stepping','CPU family','CPU op-mode(s)','Model']:
            continue
        elif key.startswith('NUMA'):
            continue
        elif key.endswith('cache'):
            info[key.lower()] = int(val.rstrip('K'))
        elif key == 'CPU(s)':
            cpus = int(val)
            info['cpus'] = cpus
        elif key == 'Thread(s) per core':
            tpc = int(val)
        elif key == 'Core(s) per socket':
            cps = int(val)
            info['corespersocket'] = cps
        elif key == 'Socket(s)':
            sockets = int(val)
            info['sockets'] = sockets
        elif key in ['CPU MHz', 'CPU max MHz','BogoMIPS','CPU min MHz']:
            info[key.lower()] = float(val)
        elif key == 'Model name':
            info['model'] = val
        elif key == 'Vendor ID':
            info['vendor'] = val
        else:
            info[key.lower()] = str(val)
    info['cores'] = cps * sockets
    return info

def meminfo():
    """Report memory, swap, hugepages"""
    info = dict()
    meminfo = getfile('/proc/meminfo')
    for line in meminfo.splitlines():
        words = line.split()
        key, val = words[0].replace(':','').lower(), words[1]
        if key in ['memtotal','memfree','swaptotal','swapfree','hugepages_total', 'hugepages_free','hugepagesize']:
            info[key] = int(val)
    return info

def uname():
    info = dict()
    sysname, nodename, release, version, machine = os.uname()
    info = {
        'sysname': sysname,
        'nodename': nodename,
        'release': release,
        'version': version,
        'machine': machine
        }
    return info

def mounts():
    """Report mounted filesystems, except 'nodev' but including nfs and nfs4"""
    arr = []
    fslist = ['nfs','nfs4']
    with open('/proc/filesystems') as fs:
        for line in fs.readlines():
            p1, p2 = line.rstrip('\n').split('\t')
            if p1 == '':
                fslist.append(p2)
    data = getfile('/proc/mounts')
    for line in data.splitlines():
        dev, mp, fstype, opts, _, _ = line.split()
        if fstype in fslist:
            arr.append({
                'dev': dev,
                'mountpoint': mp,
                'fstype': fstype,
                'options': opts
            })
    return arr

def network():
    """Report network interfaces (including virtual) and their addresses"""
    arr = []
    for dev in os.listdir('/sys/class/net'):
        if dev in ['lo']:
            continue
        if not os.path.isdir(os.path.join('/sys/class/net', dev)):
            continue
        ips = []
        speed = getfile('/sys/class/net/%s/speed' % dev)
        mtu = getfile('/sys/class/net/%s/mtu' % dev)
        mac = getfile('/sys/class/net/%s/address' % dev)
        for line in run('ip', dev).splitlines():
            words = line.split()
            addr = words[3]
            ip, prefix = addr.split('/')
            ips.append(addr)
        arr.append({
            'interface': dev,
            'ipaddr': ips,
            'speed': int(speed) if speed else None,
            'mtu': int(mtu) if mtu else None,
            'mac': mac if mac else None
        })
    return arr

def dist():
    info = dict()
    distname, version, distid = platform.linux_distribution()
    info = {
        'distro': distname,
        'version': version,
        'id': distid
    }
    return info

def hostinfo(output=None):
    info = {
        'build':       __version__,
        'cpuinfo':     cpuinfo(),
        'devices':     devices(),
        'dist':        dist(),
        'filesystems': filesystems(),
        'hostname':    socket.gethostbyaddr(socket.gethostname())[0],
        'ipaddr':      ipaddr(),
        'meminfo':     meminfo(),
        'mounts':      mounts(),
        'interfaces':  network(),
        'release':     getfile('/etc/system-release'),
        #'timestamp':   timestamp(),
        'uname':       uname(),
        'sysvendor':   getfile('/sys/class/dmi/id/sys_vendor'),
    }
    info.update(timestamp())
    if output:
        with open(output, 'w') as f:
            json.dump(info, f, indent=2,sort_keys=True)
    else:
        json.dump(info, sys.stdout, indent=2,sort_keys=True)

#============================================================================
# Main section - parsing options etc
# ---------------------------------------------------------------------------

outfile = '/tmp/%s.json' % name

parser = argparse.ArgumentParser(description='system info collector', epilog=helptext,
        formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument("-V", "--version",   action="store_true", help="Version and copyright info")
parser.add_argument("-D", "--debug",     action="store_true", help="Debug (Show errors)")
parser.add_argument("-s", "--show" ,     action="store_true", help="Show results")
parser.add_argument("-o", "--output",    type=str, help="output file (%s)" % outfile, default=outfile)

args = parser.parse_args()

if not args.debug:
    redir_stderr('/tmp/%s.log' % name)

if args.version:
    print "Name:      %s" % name
    print "Author:    %s" % __author__
    print "Copyright: %s" % __copyright__
    print "License:   %s" % __license__
    print "Build:     %s" % __version__
else:
    if args.show:
        hostinfo()
    else:
        hostinfo(args.output)
